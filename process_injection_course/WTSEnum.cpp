// WTSEnum.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <stdio.h>
#include <Windows.h>
#include <WtsApi32.h> //these functions relate to terminal services, however they work quite well in a real env. MUST be imported AFTER windows.h, as it is a subset. otherwise the prpogram breaks at compilation
#include <string>

#pragma comment(lib, "WtsApi32.lib") //as this project needs a library not linkedby default, we use a prgma to tell the linker to include this from the beginning

//the below code was pastad in at the end of one oth e lesson in roder to enable debug privs prior to proc enuumeration, this allows for more PIDs to be enumerated. The code was not covered however it appears self explainatory to a degree
bool EnableDebugPrivilege() {
    HANDLE hToken;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken))
        return false;

    TOKEN_PRIVILEGES tp;
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    if (!LookupPrivilegeValue(nullptr, SE_DEBUG_NAME, &tp.Privileges[0].Luid))
        return false;

    BOOL success = AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp), nullptr, nullptr);
    CloseHandle(hToken);

    return success && GetLastError() == ERROR_SUCCESS;
}
// end debug priv code block

std::wstring GetUserNameFromSid(PSID sid){ //std::wstring is simply telling the compiler to look in the std (standard) namespace for the wstring idintifier
    //wstring is a CPP type which allows us to store a string safely without allocating memory properly
    //a SID is a binary variable length structure, in a string-like form. However will not immediately yield the actual username 
    //SYSTEM has a universal SID, and as such can be determined. standard users though have a unique SID allocated at user creation
    if (sid == nullptr)
        return L""; //return a unicode empty string if we do not have privileges to enumerate SID
    WCHAR name[32],domain[32]; //create a string for name and for domain
    DWORD lname = _countof(name), ldomain = _countof(domain); // create the length name and domain, we do not simply specify [32], as we ever change the length  of our created strings, the value will be pointed to inherently
    SID_NAME_USE use; //sid name use will determine what type of sid we are dealing with
    if (!LookupAccountSid(nullptr, sid, name, &lname, domain, &ldomain, &use))//this allows us to obtain both domain and username from a sid - firts arg is where to look, nullptr is local system
        return L""; //return a unicode empty string if the sid lookup fails for whichever reason

    return std::wstring(domain) + L"\\" + name; //construct a nice looking string with domain\user
} 
int main()
{
    EnableDebugPrivilege();
    DWORD level = 1; //DWORD 1 is extended information
    WTS_PROCESS_INFO_EX* info; //here we will create a pointer to a pointer, this object is filled by the function, and then referenced (NOTE we could have also used WTS_PROCESS_INFO_EX*)
    DWORD count;
    BOOL success = WTSEnumerateProcessesEx(WTS_CURRENT_SERVER_HANDLE, &level, WTS_ANY_SESSION, (LPWSTR*)&info, &count); //first param is our local server (we can also open connections to OTHER servers), second is level of info returned, then the sessuon we are enumerating (we want all so we use ANY_, third is a pointer to the pointer containing proc information, next is number of procs)
    if (!success)
        return 1;

    for (DWORD i = 0; i < count; i++) { //create a for loop, iterating through i in count, we increase i so long as i is less than i in count
        PWTS_PROCESS_INFO_EX p = info + i; //here we say that for each DWORD in the structure, for each PROC we will store a pointer to it, to call when we print
        printf("PID %6u THREAD: %3u Session: %u %ws (USERNAME: %ws)\n",
            p->ProcessId, p->NumberOfThreads, p->SessionId, p->pProcessName, //with the '->' operator, we are accessing members of our created structure through a pointer
            GetUserNameFromSid(p->pUserSid).c_str()); //as  the result of pUserSid is going to be displayed as a string in the printf commnand 2 lines up, we need to get to the internal pointer to that result , we do these with .c_str() - this is just "somthinug you need to know in cpp
    }

    WTSFreeMemoryEx(WTSTypeProcessInfoLevel1, info, count); //now we release the memory we used for enumeration, specifying the level we enumerated aswell as pointer to the stored info and count
    return 0;
}
