## Process Injection Introduction  

### Why do we want to do process injection?  
[.] To be stealthy and avoid detection (running custom processes is very visble and detectable/suspicious)  
[.] We want to hide in a legitimate process  

### 32 vs 64bit?
[.] Most systems are 64bit32bit executables can run on 64bit due to an interception layer called "Wow64" (windows on windows64)  
[.] This layer translates syscalls that are 32bit to 64bit syscalls.  
[.] We must take this into consideration for the folowing reasons:  
[.] A 32bit DLL cannot be loaded by a 64bit process and vice versa  
[.] 32bit shellcode is obviously different from 64bit shellcode  


Techniques:
One thing these all have in common is that they are user mode only, these are ordered by complexity.  
[.] injecting DLL with a remote thread  
[.] Injecting a DLL with an APC  
[.] injecting a DLL with thread hijacking  
[.] injecting a DLL with windows hooks  
[.] Process hollowing  



<h2>Technique 1 - Remote Thread Injection</h2>
<details>
  <summary></summary>  
  
Injection of a dll into another poccess using a remote thread  
[.] Idea is to take and create a thread in a target process and instruct that thread to load our dll, once our dll is called we can do anything :)  
[.] This is one of the oldest techniques and most easily detectable, however we will study this anyway as it is best practice to understand this technique as it lays the foundations for other, more advanced techniques

What does it look like?  

we have a target process in which we want to load our DLL  
Then we have our attacker process, which will want a handle to the target process, and write the path to the dll via the writeProcessMemory function. Next it will call the CreateRemoteThread function in order to create anotehr thread that will tell the thread to start running where the function loadlibrary is (the load library function obviously will load a dll) and then our injected dll will be loaded into memory)  

#### API calls used:
[.] `OpenProcess` (open a handle to target process)  
[.] `VirtualAllocEx` (allocate memory in target process)  
[.] `WriteProcessMemory` (write the DLL path to target process)  
[.] `CreateRemoteThread` (create a thread in the target process)  
[.] `LoadLibrary` (load our DLL)  
  </details>

<h2>Technique 2 - APC Injection</h2>
<details>
  <summary></summary>  
  
Stands for "Asynchronous Procedure Call"  
An APC is an object holding a function ptr, and upto 3 parameters, targeted at a specific 
thread.  
There are 3 types of APCS on windows:  
Kernel PC  
Special Kernel  
Usermode APC - this is the focus of this section  

User mode APCs can be queued to a thread uysing the apicall "queueAPC"  
To get the Usermode APC to execute, the thread must go into an "Alertable" state
We achieve this state by calling one of several winAPis with teh last arg set to TRUE.
Some of these APIs are: SleepEx, WaitForSingleObjectEx. WaitForMultipleObjectsEx, and a few 
others.  
By setting one of the aforementioned call's last arg to TRUE, we are effectively saying that we 
want the thread to wait, but be alertable, hence fulfilling our alertable state requirement. Any
queued APCs will be ran upon entering alertable state. Also, if NO APCs are queued, any new ones
entering the queue will be executed immediately.  

What does it look like?  
The idea is that we call QueueUserAPC on the thread that is part of the processes where we want 
to inject our code.

How do we find a suitable thread candidate on our target process? (meaning it will enter an 
alertable state)  
Well, we can simply queue the APC to ALL threads in the process (spray and pray)  
The APC will then load our malicious DLL.
A good target for this attack are Thread pool Threads because when they wait for work, they wait
in an alertable state. As most processes contains these types of threads, it is generally easy 
to find at least one processes that execute our APC.  

Conceptually, this attack works by enumerating each thread in a processes, for each thread we 
discover we will call QueueUserAPC, and once again call the LoadLibrary function, loading our 
malicious DLL.  
This is huge upgrade over remote thread injection as we are no longer creating a new thread, but
rather injecting an existing one, which is much more inconpicious and far less visible.  

Pros
[.] Generally stealthy, as no new thread is CreateRemoteThread  
[.] Can be used to invoke an arbitrary function with up to 3 parameters (NtQueueApcThread allows
passing 3 params)  
Cons  
[.] Requires a thread to enter an alertable state (thread pool threads are ideal targets as 
these wait in an alertable state)

Detectable by:
[.] Function hooking anti-malware
[.] ETW Event in Windows 10 version 1809+
</details>

<h2>Technique 3 - Thread Hijack</h2>
<details>
  <summary></summary>  
  
A bit more modern than previous examples; this technique finds a thread in the target process
Redirects it to run attacker's shellcode (written to target process beforehand, needs to cause thread to return to it's original state to avoid crash)
Restore thread's context to it's original state.

1. Suspend the thread, 
2. redirect to our shellcode (the shellcode will call load library to load our dll
3. return to suspended execution)

This attack requires us to declare placeholder shellcode (both 32 and 64bit) that will:  
preserve the registers in the stack  
push path to dll onto the stack to fulfill the first argument for load libray function  
move pointer to load library function into eax, call the ptr to function in eax  
retrieve our stored registers  
push the address we want the thread to return to, we would have saved this via THREAD_CONTEXT  
  
  PROS:
  [.] Stealthy (no REAL way to know that this happened, simply looks like the thread went and executed some code)  
  [.] CONS:  
 [.] Requires shellcode (not really a con IMO, but this makes the technique platform-specific and would require tradecraft to write)    
 [.] Thread may be in a wait state as far as the kernel is concerned  
  
  Detectable by:  
  [.] Function hooking anti-malware (can be circumvented from ntdll)  

</details>

<h2>Technique 4 - Windows hooks</h2>
<details>
  <summary></summary>  

A windows hook is set up by calling `SetWindowsHookEx`/  
This call allows us to inject a DLL to a target process or ALL processes in the current desktop.  
It is however limited to process that load user32.dll (typically UI processes, so will not work with any processes without a UI)  
Using this function is very easy, so if there are targetable procceses, this is a very nice way of getting a DLL into a processes.  

There are several types of hooks as per the documentation [!HERE](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa) and we can see that the first param is the ID of a hook.  
Some examples of available hooks for UI procceses are: to intercept messages and low level keywords events. There are many possibilities.  

So what we want to do with our PoC is a bit more involved than prvious examples.  

We are going to get a target process and load windows hooks after we inject our dll into our SOURCE process, and then we will set up a 2-way communication between our attacker process and target process to monitor keyboard messages. We will transfer them into a callback that will be waiting on the attacking process. This will allow us to capture key input.  

Not as suspicious as other methods as this is done by windows itself  

Pros  
[.] Easy to use  
[.] Non-trivial to decide if malicious  
Cons  
[.] Requires a DLL on disk  
[.] Target process must be using User32.dll  
[.] injected process must remain alive (we can however chain with ANOTHER injection technique to inject another process)  

Detectable by:  
[.] DLL loading (however not definitive, can still be bypassed)  
</details>


<h2>Technique 4 - Process Hollowing</h2>
<details>
  <summary></summary>  
In this technique, we are going to create a legitmaite process such as notepad or something else and replace the executable code inside that process with our malicious payload.  
To achieve this, the porcess must be created in suspended state. So the process will exist, the main thread will exist, but it will not start executing any code from the original executable. So after we cal the process with createprocess, we will need to provide our own executable and map it to the target process. This will require some adjustments such as point to the new image from the process environment block (PEB) which is a usermode structure that must be kept in sync with regards to what is occuring inside the processes. After we resume the thread, the thread will begin execution of our replacment code. We no longer need the attacker process after this point.  

A brief primer on the "Portable Executable" format is necessary in order to understand the next part.  
PE is the basic format of all executable images on windows (EXE, DLL, SYS, OCX, EFI, etc)  
Fully recognized and documented by microsoft  
These files are loaded by the laoder and then recognised, parsed, and then mapped into system space.  

The PE file structure is as follows.  

A PE file can contain three types of information: Code, data, and resources (strings, icons, bitmaps, etc)  
Part of the PE structure contains headers with information such as which PE version it is, architecture (32/64), what machie type it is appropriate for.  
After this we have the sections which contain the information itself such as the code, data, lists of data referenced by imports/exports, what the image needs to bind to in order to work properly.  
We will need know this basic information in regards to how a PE structure is built as we are going to play the role of the loader when we copy our replacement execuable into the target process. We must make it as though the loader has loaded it.  

What have we done:  

Used `CreateProcess` to create legitimate process  
Used `CreateFile` to open our replacement executable file  
Use `VirtualAllocEx` to allocate the memory in target process  
We use `ReBaseImage64` to make sure that the executable is aligned with the address its going to be loaded into so no import amendments need to be made  
Utilise `CreateFileMapping` and `MapViewofFileEx` to make it easier to copy from source to target  
`WriteProcessMemory` to copy headers and sections  
Use `NtQueryInformationProcess` to gain the PEB address of target process in order to make amendments  
Use `GetThreadContext` and `SetThreadContext` to make the changes  
And finally `ResumeThread` to end the intial suspended state.  

Pros  
[.] Hard to conclude as being malicious  
[.] Fairly well-hidden  
[.] Replacement code cand be on disk or memory  

Cons  
[.] requires creating a new process which anti-malware is suspicious of (hwoever we will be using a valid process, so detection rates drop)  
[.] Executable memory allocated  

Detectable by  
[.] Payload being opened from disk  
[.] Hollowing code implementation  
</details>
