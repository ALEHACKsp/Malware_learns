C# usage in powershell

_Why do we want to do this?_

This allows us to directRandom_notesly declare and import win32apis using dll import attribute class.  
this allows us to invoke functions in unmanaged dlls.  
We do this with pInvoke, we import using the "directive" keyword.  

As an example, we will translate into a c# method signature.  

the official page tells us The c# signature  
`[DllImport("user32.dll", SetLastError = true, CharSet= CharSet.Auto)]  
public static extern int MessageBox(IntPtr hWnd, String text, String caption, uint type);`

we will need to import the namespaces containing the pinvoke apis.  

We start by creating a c# class, which will import the dll containing the msgbox signature, after this we import the class using the `Add-Type` keyword, this forces the .dotnet framework to compile and create an object containg the structures, functions, values etc.
So essentially, add-type uses .dotnet to compile the c# code containing the win32api declarations.  
The below is simply creating a variable and sets it to a block of text ("@") declares a block of text.  
After this, we compile by passing our object containing csharp code to Add-Type
```
$User32 = @"
using System;
using System.Runtime.InteropServices;

public class User32 {
    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    public static extern int MessageBox(IntPtr hwnd, String text,
        String caption, int options)

}
"@

Add-Type $User32
```

Now that we have compiled our c# code, we can execute by calling our instantiated User32 object, and to this we call the MessageBox win32api call, and pass it our args as we would in c++

```
[User32]::MessageBox(0, "This is an alert", "Mybox", 0)
```

I will dive deeper into DInvoke at some stage  

### DInvoke 
D/Invoke has an excellent method called GetSyscallStub that will read ntdll from disk and find the syscall for a given API.

//setup function pointer, similar to when we covered call obfuscation from sektor7's course in c++
`
public static object DynamicAPIInvoke(string DLLName, string FunctionName, Type FunctionDelegateType, ref object[] Parameters)
{
    IntPtr pFunction = GetLibraryAddress(DLLName, FunctionName);
    return DynamicFunctionInvoke(pFunction, FunctionDelegateType, ref Parameters);
}
`

//create a delegate from function pointer and invoke the function wrapped by the delegate, passing provided parameters in an object array. Data MUST be passed in structured in the way the code expects
public static object DynamicFunctionInvoke(IntPtr FunctionPointer, Type FunctionDelegateType, ref object[] Parameters)

*delegation allows us to say Hey there is going to be a function later with this return type and parameters sometime later. Then we say here remember how i said there was going to be a function? Well i defined it here (pointing then to our shellcode, hence function pointer), now please run it :)*

`{  
    Delegate funcDelegate = Marshal.GetDelegateForFunctionPointer(FunctionPointer, FunctionDelegateType);  
    return funcDelegate.DynamicInvoke(Parameters);  
}`
```
using System;  
using System.Runtime.InteropServices;  

namespace ConsoleApp1  
{  
    class Program  
    {  
    static void Main(string[] args)  
        {  
            var hProcess = OpenProcess(  
                0x001F0FFF,  
                false,  
                int.Parse(args[0]));  
        }  

        [DllImport("user32.dll", SetLastError = true, CharSet= CharSet.Auto)]  
        public static extern int MessageBox(  
        IntPtr hWnd,String text,  
        String caption,  
        uint type);  
```


```
[DllImport("kernel32.dll")]  
        static extern IntPtr OpenProcess(  
            int dwDesiredAccess,  
            bool bInheritHandle,  
            int dwProcessId);  
[UnmanagedFunctionPointer(CallingConvention.StdCall)]  
delegate NTSTATUS NtOpenProcess(  
    ref IntPtr ProcessHandle,  
    uint DesiredAccess,  
    ref OBJECT_ATTRIBUTES ObjectAttributes,  
    ref CLIENT_ID ClientId);```  
