C# usage in powershell

_Why do we want to do this?_

This allows us to directRandom_notesly declare and import win32apis using dll import attribute class.  
this allows us to invoke functions in unmanaged dlls.  
We do this with pInvoke, we import using the "directive" keyword.  

As an example, we will translate into a c# method signature.  

the official page tells us The c# signature  
`[DllImport("user32.dll", SetLastError = true, CharSet= CharSet.Auto)]  
public static extern int MessageBox(IntPtr hWnd, String text, String caption, uint type);`

we will need to import the namespaces containing the pinvoke apis.  

We start by creating a c# class, which will import the dll containing the msgbox signature, after this we import the class using the `Add-Type` keyword, this forces the .dotnet framework to compile and create an object containg the structures, functions, values etc.
So essentially, add-type uses .dotnet to compile the c# code containing the win32api declarations.  
The below is simply creating a variable and sets it to a block of text ("@") declares a block of text.  
After this, we compile by passing our object containing csharp code to Add-Type
```
$User32 = @"
using System;
using System.Runtime.InteropServices;

public class User32 {
    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    public static extern int MessageBox(IntPtr hwnd, String text,
        String caption, int options)

}
"@

Add-Type $User32
```

Now that we have compiled our c# code, we can execute by calling our instantiated User32 object, and to this we call the MessageBox win32api call, and pass it our args as we would in c++

```
[User32]::MessageBox(0, "This is an alert", "Mybox", 0)
```
