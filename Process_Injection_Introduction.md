## Process Injection Introduction  

### Why do we want to do process injection?  
[.] To be stealthy and avoid detection (running custom processes is very visble and detectable/suspicious)  
[.] We want to hide in a legitimate process  

### 32 vs 64bit?
[.] Most systems are 64bit32bit executables can run on 64bit due to an interception layer called "Wow64" (windows on windows64)  
[.] This layer translates syscalls that are 32bit to 64bit syscalls.  
[.] We must take this into consideration for the folowing reasons:  
[.] A 32bit DLL cannot be loaded by a 64bit process and vice versa  
[.] 32bit shellcode is obviously different from 64bit shellcode  


Techniques:
One thing these all have in common is that they are user mode only, these are ordered by complexity.  
[.] injecting DLL with a remote thread  
[.] Injecting a DLL with an APC  
[.] injecting a DLL with thread hijacking  
[.] injecting a DLL with windows hooks  
[.] Process hollowing  



<h2>Technique 1 - Remote Thread Injection</h2>
<details>
  <summary></summary>  
  
Injection of a dll into another poccess using a remote thread  
[.] Idea is to take and create a thread in a target process and instruct that thread to load our dll, once our dll is called we can do anything :)  
[.] This is one of the oldest techniques and most easily detectable, however we will study this anyway as it is best practice to understand this technique as it lays the foundations for other, more advanced techniques

What does it look like?  

we have a target process in which we want to load our DLL  
Then we have our attacker process, which will want a handle to the target process, and write the path to the dll via the writeProcessMemory function. Next it will call the CreateRemoteThread function in order to create anotehr thread that will tell the thread to start running where the function loadlibrary is (the load library function obviously will load a dll) and then our injected dll will be loaded into memory)  

#### API calls used:
[.] `OpenProcess` (open a handle to target process)  
[.] `VirtualAllocEx` (allocate memory in target process)  
[.] `WriteProcessMemory` (write the DLL path to target process)  
[.] `CreateRemoteThread` (create a thread in the target process)  
[.] `LoadLibrary` (load our DLL)  
  </details>

<h2>Technique 2 - APC Injection</h2>
<details>
  <summary></summary>  
  
Stands for "Asynchronous Procedure Call"  
An APC is an object holding a function ptr, and upto 3 parameters, targeted at a specific 
thread.  
There are 3 types of APCS on windows:  
Kernel PC  
Special Kernel  
Usermode APC - this is the focus of this section  

User mode APCs can be queued to a thread uysing the apicall "queueAPC"  
To get the Usermode APC to execute, the thread must go into an "Alertable" state
We achieve this state by calling one of several winAPis with teh last arg set to TRUE.
Some of these APIs are: SleepEx, WaitForSingleObjectEx. WaitForMultipleObjectsEx, and a few 
others.  
By setting one of the aforementioned call's last arg to TRUE, we are effectively saying that we 
want the thread to wait, but be alertable, hence fulfilling our alertable state requirement. Any
queued APCs will be ran upon entering alertable state. Also, if NO APCs are queued, any new ones
entering the queue will be executed immediately.  

What does it look like?  
The idea is that we call QueueUserAPC on the thread that is part of the processes where we want 
to inject our code.

How do we find a suitable thread candidate on our target process? (meaning it will enter an 
alertable state)  
Well, we can simply queue the APC to ALL threads in the process (spray and pray)  
The APC will then load our malicious DLL.
A good target for this attack are Thread pool Threads because when they wait for work, they wait
in an alertable state. As most processes contains these types of threads, it is generally easy 
to find at least one processes that execute our APC.  

Conceptually, this attack works by enumerating each thread in a processes, for each thread we 
discover we will call QueueUserAPC, and once again call the LoadLibrary function, loading our 
malicious DLL.  
This is huge upgrade over remote thread injection as we are no longer creating a new thread, but
rather injecting an existing one, which is much more inconpicious and far less visible.  

Pros
[.] Generally stealthy, as no new thread is CreateRemoteThread  
[.] Can be used to invoke an arbitrary function with up to 3 parameters (NtQueueApcThread allows
passing 3 params)  
Cons  
[.] Requires a thread to enter an alertable state (thread pool threads are ideal targets as 
these wait in an alertable state)

Detectable by:
[.] Function hooking
[.] ETW Event in Windows 10 version 1809+
</details>
